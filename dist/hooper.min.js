var t, i;
(t = this),
  (i = function(t, i) {
    'use strict';
    function c(t, i, e) {
      return (
        i in t ? Object.defineProperty(t, i, { value: e, enumerable: !0, configurable: !0, writable: !0 }) : (t[i] = e),
        t
      );
    }
    function h(i) {
      for (var t = 1; t < arguments.length; t++) {
        var e = null != arguments[t] ? arguments[t] : {},
          n = Object.keys(e);
        'function' == typeof Object.getOwnPropertySymbols &&
          (n = n.concat(
            Object.getOwnPropertySymbols(e).filter(function(t) {
              return Object.getOwnPropertyDescriptor(e, t).enumerable;
            })
          )),
          n.forEach(function(t) {
            c(i, t, e[t]);
          });
      }
      return i;
    }
    function u(t) {
      return (
        (function(t) {
          if (Array.isArray(t)) {
            for (var i = 0, e = new Array(t.length); i < t.length; i++) e[i] = t[i];
            return e;
          }
        })(t) ||
        (function(t) {
          if (Symbol.iterator in Object(t) || '[object Arguments]' === Object.prototype.toString.call(t))
            return Array.from(t);
        })(t) ||
        (function() {
          throw new TypeError('Invalid attempt to spread non-iterable instance');
        })()
      );
    }
    function n() {
      return Date.now();
    }
    function e(t, i) {
      (this.create = function() {
        return window.setInterval(t, i);
      }),
        (this.stop = function() {
          this.timer && (window.clearInterval(this.timer), (this.timer = null));
        }),
        (this.start = function() {
          this.timer || (this.timer = this.create());
        }),
        (this.restart = function() {
          this.stop(), this.start();
        }),
        (this.timer = this.create());
    }
    function l(t, i) {
      var e;
      return (e = t < 0 ? (t + i) % i : t % i) != e ? 0 : e;
    }
    function d(t, i) {
      var e = i.children || i.componentOptions.children || i.text;
      return t(i.componentOptions.Ctor, i.data, e);
    }
    i = i && i.hasOwnProperty('default') ? i.default : i;
    var r =
      Object.assign ||
      function(t) {
        if (null == t) throw new TypeError('Cannot convert first argument to object');
        for (var i = Object(t), e = 1; e < arguments.length; e++) {
          var n = arguments[e];
          if (null != n) {
            n = Object(n);
            for (var r = Object.keys(Object(n)), o = 0, s = r.length; o < s; o++) {
              var a = r[o],
                h = Object.getOwnPropertyDescriptor(n, a);
              void 0 !== h && h.enumerable && (i[a] = n[a]);
            }
          }
        }
        return i;
      };
    var o =
      Math.sign ||
      function(t) {
        return t < 0 ? -1 : 0 < t ? 1 : 0;
      };
    function p(t, i) {
      var e = 1 < arguments.length && void 0 !== i ? i : {};
      return t.$scopedSlots.default ? t.$scopedSlots.default(e) || [] : t.$slots.default || [];
    }
    var f = new i(),
      s = {
        name: 'Hooper',
        provide: function() {
          return { $hooper: this };
        },
        props: {
          itemsToShow: { default: 1, type: Number },
          itemsToSlide: { default: 1, type: Number },
          initialSlide: { default: 0, type: Number },
          infiniteScroll: { default: !1, type: Boolean },
          centerMode: { default: !1, type: Boolean },
          vertical: { default: !1, type: Boolean },
          rtl: { default: null, type: Boolean },
          autoPlay: { default: !1, type: Boolean },
          playSpeed: { default: 2e3, type: Number },
          mouseDrag: { default: !0, type: Boolean },
          touchDrag: { default: !0, type: Boolean },
          wheelControl: { default: !0, type: Boolean },
          keysControl: { default: !0, type: Boolean },
          shortDrag: { default: !0, type: Boolean },
          transition: { default: 300, type: Number },
          hoverPause: { default: !0, type: Boolean },
          trimWhiteSpace: { default: !1, type: Boolean },
          settings: {
            default: function() {
              return {};
            },
            type: Object
          },
          group: { type: String, default: null }
        },
        data: function() {
          return {
            isDragging: !1,
            isSliding: !1,
            isTouch: !1,
            isHover: !1,
            isFocus: !1,
            initialized: !1,
            slideWidth: 0,
            slideHeight: 0,
            slidesCount: 0,
            trimStart: 0,
            trimEnd: 1,
            currentSlide: null,
            timer: null,
            defaults: {},
            breakpoints: {},
            delta: { x: 0, y: 0 },
            config: {}
          };
        },
        computed: {
          slideBounds: function() {
            var t = this.config,
              i = this.currentSlide,
              e = t.itemsToShow;
            return {
              lower: t.centerMode ? Math.ceil(i - e / 2) : i,
              upper: t.centerMode ? Math.floor(i + e / 2) : Math.floor(i + e - 1)
            };
          },
          trackTransform: function() {
            var t = this.config,
              i = t.infiniteScroll,
              e = t.vertical,
              n = t.rtl,
              r = t.centerMode,
              o = n ? -1 : 1,
              s = e ? this.slideHeight : this.slideWidth,
              a = e ? this.containerHeight : this.containerWidth,
              h =
                (e ? this.delta.y : this.delta.x) +
                o * ((r ? (a - s) / 2 : 0) - (i ? s * this.slidesCount : 0) - this.currentSlide * s);
            return e ? 'transform: translate(0, '.concat(h, 'px);') : 'transform: translate('.concat(h, 'px, 0);');
          },
          trackTransition: function() {
            return this.initialized && this.isSliding ? 'transition: '.concat(this.config.transition, 'ms') : '';
          }
        },
        watch: {
          group: function(t, i) {
            t !== i && (f.$off('slideGroup:'.concat(i), this._groupSlideHandler), this.addGroupListeners());
          },
          autoPlay: function(t, i) {
            t !== i && this.restartTimer();
          }
        },
        methods: {
          slideTo: function(t, i) {
            var e = this,
              n = !(1 < arguments.length && void 0 !== i) || i;
            if (!this.isSliding && t !== this.currentSlide) {
              this.$emit('beforeSlide', { currentSlide: this.currentSlide, slideTo: h });
              var r = this.config,
                o = r.infiniteScroll,
                s = r.transition,
                a = this.currentSlide,
                h = o
                  ? t
                  : (function(t, i, e) {
                      return Math.max(Math.min(t, e), i);
                    })(t, this.trimStart, this.slidesCount - this.trimEnd);
              this.group && n && f.$emit('slideGroup:'.concat(this.group), t),
                (this.currentSlide = h),
                (this.isSliding = !0),
                window.setTimeout(function() {
                  (e.isSliding = !1), (e.currentSlide = l(h, e.slidesCount));
                }, s),
                this.$emit('slide', { currentSlide: this.currentSlide, slideFrom: a });
            }
          },
          slideNext: function() {
            this.slideTo(this.currentSlide + this.config.itemsToSlide);
          },
          slidePrev: function() {
            this.slideTo(this.currentSlide - this.config.itemsToSlide);
          },
          initEvents: function() {
            null === this.defaults.rtl && (this.defaults.rtl = 'rtl' === getComputedStyle(this.$el).direction),
              this.$props.autoPlay && this.initAutoPlay(),
              this.config.mouseDrag && this.$refs.list.addEventListener('mousedown', this.onDragStart),
              this.config.touchDrag &&
                (this.$refs.list.addEventListener('touchstart', this.onDragStart),
                this.$refs.list.addEventListener(this.isTouch ? 'touchmove' : 'mousemove', this.onDrag),
                this.$refs.list.addEventListener(this.isTouch ? 'touchend' : 'mouseup', this.onDragEnd)),
              this.config.keysControl && this.$el.addEventListener('keydown', this.onKeypress),
              this.config.wheelControl &&
                ((this.lastScrollTime = n()), this.$el.addEventListener('wheel', this.onWheel, { passive: !1 })),
              window.addEventListener('resize', this.update);
          },
          initAutoPlay: function() {
            var t = this;
            this.timer = new e(function() {
              t.isSliding ||
                t.isDragging ||
                (t.isHover && t.config.hoverPause) ||
                t.isFocus ||
                !t.$props.autoPlay ||
                (t.currentSlide !== t.slidesCount - 1 || t.config.infiniteScroll ? t.slideNext() : t.slideTo(0));
            }, this.config.playSpeed);
          },
          initDefaults: function() {
            (this.breakpoints = this.settings.breakpoints),
              (this.defaults = r({}, this.$props, this.settings)),
              (this.config = r({}, this.defaults));
          },
          update: function() {
            this.breakpoints && this.updateConfig(),
              this.updateWidth(),
              this.updateTrim(),
              this.$emit('updated', {
                containerWidth: this.containerWidth,
                containerHeight: this.containerHeight,
                slideWidth: this.slideWidth,
                slideHeight: this.slideHeight,
                settings: this.config
              });
          },
          updateTrim: function() {
            var t = this.config,
              i = t.trimWhiteSpace,
              e = t.itemsToShow,
              n = t.centerMode,
              r = t.infiniteScroll;
            if (!i || r) return (this.trimStart = 0), void (this.trimEnd = 1);
            (this.trimStart = n ? Math.floor((e - 1) / 2) : 0), (this.trimEnd = n ? Math.ceil(e / 2) : e);
          },
          updateWidth: function() {
            var t = this.$el.getBoundingClientRect();
            (this.containerWidth = t.width),
              (this.containerHeight = t.height),
              this.config.vertical
                ? (this.slideHeight = this.containerHeight / this.config.itemsToShow)
                : (this.slideWidth = this.containerWidth / this.config.itemsToShow);
          },
          updateConfig: function() {
            var i,
              e = this;
            Object.keys(this.breakpoints)
              .sort(function(t, i) {
                return i - t;
              })
              .some(function(t) {
                if ((i = window.matchMedia('(min-width: '.concat(t, 'px)')).matches))
                  return (e.config = r({}, e.config, e.defaults, e.breakpoints[t])), !0;
              }),
              i || (this.config = r(this.config, this.defaults));
          },
          restartTimer: function() {
            var t = this;
            this.$nextTick(function() {
              null === t.timer && t.$props.autoPlay
                ? t.initAutoPlay()
                : t.timer && (t.timer.stop(), t.$props.autoPlay && t.timer.start());
            });
          },
          restart: function() {
            var t = this;
            this.$nextTick(function() {
              t.update();
            });
          },
          onDragStart: function(t) {
            (this.isTouch = 'touchstart' === t.type),
              (!this.isTouch && 0 !== t.button) ||
                ((this.startPosition = { x: 0, y: 0 }),
                (this.endPosition = { x: 0, y: 0 }),
                (this.isDragging = !0),
                (this.startPosition.x = this.isTouch ? t.touches[0].clientX : t.clientX),
                (this.startPosition.y = this.isTouch ? t.touches[0].clientY : t.clientY));
          },
          isInvalidDirection: function(t, i) {
            return this.config.vertical
              ? !!this.config.vertical && Math.abs(i) <= Math.abs(t)
              : Math.abs(t) <= Math.abs(i);
          },
          onDrag: function(t) {
            if (!this.isSliding) {
              (this.endPosition.x = this.isTouch ? t.touches[0].clientX : t.clientX),
                (this.endPosition.y = this.isTouch ? t.touches[0].clientY : t.clientY);
              var i = this.endPosition.x - this.startPosition.x,
                e = this.endPosition.y - this.startPosition.y;
              this.isInvalidDirection(i, e) || ((this.delta.y = e), (this.delta.x = i), t.preventDefault());
            }
          },
          onDragEnd: function() {
            var t = this.config.shortDrag ? 0.5 : 0.15;
            if (((this.isDragging = !1), this.config.vertical)) {
              var i = Math.round(Math.abs(this.delta.y / this.slideHeight) + t);
              this.slideTo(this.currentSlide - o(this.delta.y) * i);
            }
            if (!this.config.vertical) {
              var e = (this.config.rtl ? -1 : 1) * o(this.delta.x),
                n = Math.round(Math.abs(this.delta.x / this.slideWidth) + t);
              this.slideTo(this.currentSlide - e * n);
            }
            (this.delta.x = 0), (this.delta.y = 0), this.restartTimer();
          },
          onTransitionend: function() {
            (this.isSliding = !1), this.$emit('afterSlide', { currentSlide: this.currentSlide });
          },
          onKeypress: function(t) {
            var i = t.key;
            return (
              i.startsWith('Arrow') && t.preventDefault(),
              this.config.vertical
                ? ('ArrowUp' === i && this.slidePrev(), void ('ArrowDown' === i && this.slideNext()))
                : this.config.rtl
                ? ('ArrowRight' === i && this.slidePrev(), void ('ArrowLeft' === i && this.slideNext()))
                : ('ArrowRight' === i && this.slideNext(), void ('ArrowLeft' === i && this.slidePrev()))
            );
          },
          onWheel: function(t) {
            if ((t.preventDefault(), !(n() - this.lastScrollTime < 200))) {
              this.lastScrollTime = n();
              var i = t.wheelDelta || -t.deltaY,
                e = o(i);
              -1 === e && this.slideNext(), 1 === e && this.slidePrev();
            }
          },
          addGroupListeners: function() {
            var i = this;
            this.group &&
              ((this._groupSlideHandler = function(t) {
                i.slideTo(t, !1);
              }),
              f.$on('slideGroup:'.concat(this.group), this._groupSlideHandler));
          }
        },
        created: function() {
          this.initDefaults();
        },
        mounted: function() {
          var t = this;
          this.initEvents(),
            this.addGroupListeners(),
            this.$nextTick(function() {
              t.update(),
                t.slideTo(t.config.initialSlide || 0),
                setTimeout(function() {
                  t.$emit('loaded'), (t.initialized = !0);
                }, t.transition);
            });
        },
        beforeDestroy: function() {
          window.removeEventListener('resize', this.update),
            this.$refs.list.removeEventListener(this.isTouch ? 'touchmove' : 'mousemove', this.onDrag),
            this.$refs.list.removeEventListener(this.isTouch ? 'touchend' : 'mouseup', this.onDragEnd),
            this.group && f.$off('slideGroup:'.concat(this.group), this._groupSlideHandler),
            this.timer && this.timer.stop();
        },
        render: function(t) {
          var i = this,
            e = function(t) {
              var i = function(t) {
                  for (var i = p(this), e = i.length, n = 0, r = [], o = 0; o < e; o++) {
                    var s = i[o],
                      a = s.componentOptions && s.componentOptions.Ctor;
                    a &&
                      'HooperSlide' === a.options.name &&
                      ((s.componentOptions.propsData.index = n),
                      (s.data.key = n),
                      (s.key = n),
                      (s.data.props = h({}, s.data.props || {}, { isClone: !1, index: n++ })),
                      r.push(s));
                  }
                  (this.slidesCount = r.length),
                    this.config.infiniteScroll &&
                      (r = (function(t, i) {
                        for (var e = [], n = [], r = i.length, o = 0; o < r; o++) {
                          var s = i[o],
                            a = d(t, s),
                            h = o - r;
                          (a.data.key = 'before_'.concat(o)),
                            (a.key = a.data.key),
                            (a.componentOptions.propsData.index = h),
                            (a.data.props = { index: h, isClone: !0 }),
                            e.push(a);
                          var l = d(t, s);
                          (h = o + r),
                            (l.data.key = 'after_'.concat(h)),
                            (l.componentOptions.propsData.index = h),
                            (l.key = l.data.key),
                            (l.data.props = { index: h, isClone: !0 }),
                            n.push(l);
                        }
                        return [].concat(e, u(i), n);
                      })(t, r));
                  return t(
                    'ul',
                    {
                      class: { 'hooper-track': !0, 'is-dragging': this.isDragging },
                      style: this.trackTransform + this.trackTransition,
                      ref: 'track',
                      on: { transitionend: this.onTransitionend }
                    },
                    r
                  );
                }.call(this, t),
                e = this.$slots['hooper-addons'] || [],
                n = t(
                  'div',
                  {
                    class: 'hooper-liveregion hooper-sr-only',
                    attrs: { 'aria-live': 'polite', 'aria-atomic': 'true' }
                  },
                  'Item '.concat(this.currentSlide + 1, ' of ').concat(this.slidesCount)
                ),
                r = [i].concat(u(e), [n]);
              return [t('div', { class: 'hooper-list', ref: 'list' }, r)];
            }.call(this, t);
          return t(
            'section',
            {
              class: { hooper: !0, 'is-vertical': this.config.vertical, 'is-rtl': this.config.rtl },
              attrs: { tabindex: '0' },
              on: {
                focusin: function() {
                  return (i.isFocus = !0);
                },
                focusout: function() {
                  return (i.isFocus = !1);
                },
                mouseover: function() {
                  return (i.isHover = !0);
                },
                mouseleave: function() {
                  return (i.isHover = !1);
                }
              }
            },
            e
          );
        }
      };
    var a = {
        name: 'HooperSlide',
        inject: ['$hooper'],
        props: { isClone: { type: Boolean, default: !1 }, index: { type: Number, required: !0 } },
        computed: {
          style: function() {
            var t = this.$hooper || {},
              i = t.config,
              e = t.slideHeight,
              n = t.slideWidth;
            return i.vertical ? 'height: '.concat(e, 'px') : 'width: '.concat(n, 'px');
          },
          isActive: function() {
            var t = this.$hooper.slideBounds,
              i = t.upper,
              e = t.lower;
            return this.index >= e && this.index <= i;
          },
          isPrev: function() {
            var t = this.$hooper.slideBounds.lower,
              i = this.$hooper.config.itemsToSlide;
            return this.index < t && this.index >= t - i;
          },
          isNext: function() {
            var t = this.$hooper.slideBounds.upper,
              i = this.$hooper.config.itemsToSlide;
            return this.index > t && this.index <= t + i;
          },
          isCurrent: function() {
            return this.index === this.$hooper.currentSlide;
          }
        },
        render: function(t) {
          var i = {
              'hooper-slide': !0,
              'is-clone': this.isClone,
              'is-active': this.isActive,
              'is-prev': this.isPrev,
              'is-next': this.isNext,
              'is-current': this.isCurrent
            },
            e = p(this);
          return t('li', { class: i, style: this.style, attrs: { 'aria-hidden': !this.isActive } }, e);
        }
      },
      g = {
        arrowUp: 'M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z',
        arrowDown: 'M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z',
        arrowRight: 'M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z',
        arrowLeft: 'M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z'
      },
      v = {
        name: 'HooperIcon',
        functional: !0,
        inheritAttrs: !0,
        props: {
          name: {
            type: String,
            required: !0,
            validator: function(t) {
              return t in g;
            }
          }
        },
        render: function(t, i) {
          var e = i.props,
            n = g[e.name],
            r = [];
          return (
            r.push(
              t(
                'title',
                (function(t) {
                  return (t = t.replace(/([A-Z]+)/g, ' $1')).charAt(0).toUpperCase() + t.slice(1);
                })(e.name)
              )
            ),
            r.push(t('path', { attrs: { d: 'M0 0h24v24H0z', fill: 'none' } })),
            r.push(t('path', { attrs: { d: n } })),
            t(
              'svg',
              { attrs: { class: 'icon icon-'.concat(e.name), viewBox: '0 0 24 24', width: '24px', height: '24px' } },
              r
            )
          );
        }
      },
      m = {
        inject: ['$hooper'],
        name: 'HooperProgress',
        computed: {
          currentSlide: function() {
            return l(this.$hooper.currentSlide, this.$hooper.slidesCount);
          },
          progress: function() {
            var t = this.$hooper.slidesCount - this.$hooper.trimStart - this.$hooper.trimEnd;
            return (100 * (this.currentSlide - this.$hooper.trimStart)) / t;
          }
        },
        render: function(t) {
          return t('div', { class: 'hooper-progress' }, [
            t('div', { class: 'hooper-progress-inner', style: 'width: '.concat(this.progress, '%') })
          ]);
        }
      };
    var y = {
      inject: ['$hooper'],
      name: 'HooperPagination',
      props: { mode: { default: 'indicator', type: String } },
      computed: {
        currentSlide: function() {
          return l(this.$hooper.currentSlide, this.$hooper.slidesCount);
        },
        slides: function() {
          var t = this.$hooper.slides.map(function(t, i) {
            return i;
          });
          return t.slice(this.$hooper.trimStart, this.$hooper.slidesCount - this.$hooper.trimEnd + 1);
        }
      },
      render: function(t) {
        var i = this,
          e = this.$hooper.slidesCount,
          n =
            'indicator' === this.mode
              ? (function(i, e, t, n) {
                  for (
                    var r = [],
                      o = function(t) {
                        r.push(
                          (function(t, i, e, n) {
                            return t('li', [
                              t(
                                'button',
                                {
                                  class: { 'hooper-indicator': !0, 'is-active': e },
                                  on: { click: n },
                                  attrs: { type: 'button' }
                                },
                                [t('span', { class: 'hooper-sr-only' }, 'item '.concat(i))]
                              )
                            ]);
                          })(i, t, t === e, function() {
                            return n(t);
                          })
                        );
                      },
                      s = 0;
                    s < t;
                    s++
                  )
                    o(s);
                  return [i('ol', { class: 'hooper-indicators' }, r)];
                })(t, this.currentSlide, e, function(t) {
                  return i.$hooper.slideTo(t);
                })
              : (function(t, i, e) {
                  return [t('span', i + 1), t('span', '/'), t('span', e)];
                })(t, this.currentSlide, e);
        return t('div', { class: { 'hooper-pagination': !0, 'is-vertical': this.$hooper.config.vertical } }, n);
      }
    };
    function S(t, i, e, n, r, o) {
      var s,
        a = r.isVertical,
        h = r.isRTL,
        l =
          e && e.length
            ? e
            : [
                t(v, {
                  props: {
                    name: (function(t, i, e) {
                      return e
                        ? t
                          ? 'arrowUp'
                          : i
                          ? 'arrowRight'
                          : 'arrowLeft'
                        : t
                        ? 'arrowDown'
                        : i
                        ? 'arrowLeft'
                        : 'arrowRight';
                    })(a, h, n)
                  }
                })
              ];
      return t(
        'button',
        {
          class: ((s = {}), c(s, 'hooper-'.concat(n ? 'prev' : 'next'), !0), c(s, 'is-disabled', i), s),
          attrs: { type: 'button' },
          on: { click: o }
        },
        l
      );
    }
    var $ = {
      inject: ['$hooper'],
      name: 'HooperNavigation',
      computed: {
        isPrevDisabled: function() {
          return !this.$hooper.config.infiniteScroll && 0 === this.$hooper.currentSlide;
        },
        isNextDisabled: function() {
          return (
            !this.$hooper.config.infiniteScroll &&
            (this.$hooper.config.trimWhiteSpace
              ? this.$hooper.currentSlide ===
                this.$hooper.slidesCount - Math.min(this.$hooper.config.itemsToShow, this.$hooper.slidesCount)
              : this.$hooper.currentSlide === this.$hooper.slidesCount - 1)
          );
        }
      },
      methods: {
        slideNext: function() {
          this.$hooper.slideNext(), this.$hooper.restartTimer();
        },
        slidePrev: function() {
          this.$hooper.slidePrev(), this.$hooper.restartTimer();
        }
      },
      render: function(t) {
        var i = this,
          e = { isRTL: this.$hooper.config.rtl, isVertical: this.$hooper.config.vertical },
          n = [
            S(t, this.isPrevDisabled, this.$slots['hooper-prev'], !0, e, function() {
              return i.slidePrev();
            }),
            S(t, this.isNextDisabled, this.$slots['hooper-next'], !1, e, function() {
              return i.slideNext();
            })
          ];
        return t(
          'div',
          {
            class: {
              'hooper-navigation': !0,
              'is-vertical': this.$hooper.config.vertical,
              'is-rtl': this.$hooper.config.rtl
            }
          },
          n
        );
      }
    };
    (t.Hooper = s),
      (t.Icon = v),
      (t.Navigation = $),
      (t.Pagination = y),
      (t.Progress = m),
      (t.Slide = a),
      (t.addonMixin = { inject: ['$hooper'] }),
      (t.default = s),
      Object.defineProperty(t, '__esModule', { value: !0 });
  }),
  'object' == typeof exports && 'undefined' != typeof module
    ? i(exports, require('vue'))
    : 'function' == typeof define && define.amd
    ? define(['exports', 'vue'], i)
    : i(((t = t || self).Hooper = {}), t.Vue);
